<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Define an error type that includes the errors you care about</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Define an error type that includes the errors you care about</h1>
</header>
<p>Strings are not a good way to communicate many kinds of errors, both because they require parsing to extract information, and because they’re expensive. It’s better to define an error type that lets you express exactly the situations you care about in a way that’s easy to work with downstream.</p>
<p>For example, suppose that there are several kinds of errors you might experience while constructing and searching graphs:</p>
<ul>
<li>You might be given a graph to parse that contains a syntax error.</li>
<li>You may be given a search query that is improperly formed.</li>
<li>You may be given a search query that refers to a non-existent vertex label.</li>
<li>You may experience an IO error.</li>
</ul>
<p>We can define an <code>enum</code> for representing the possible errors. For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="op">,</span> <span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">pub</span> <span class="kw">enum</span> GraphError <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    BadGraphFormat<span class="op">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    QueryTooShort<span class="op">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    QueryTooLong<span class="op">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    UnknownLabel(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    IoError(<span class="pp">std::io::</span><span class="bu">Error</span>)<span class="op">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>(It’s possible to make the <code>UnknownLabel</code> variant borrow the label rather than own it, but it’s probably not worth it, as it would prevent an error from outliving the input that its label was parsed and borrowed from, which would be major a problem.)</p>
<p>If we want to generate these errors ourselves, that’s easy:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">let</span> w1  <span class="op">=</span> query_words<span class="op">.</span>next()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="op">.</span>ok_or(<span class="pp">GraphError::</span>QueryTooShort)<span class="op">?;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">let</span> w2 <span class="op">=</span> query_words<span class="op">.</span>next()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="op">.</span>ok_or(<span class="pp">GraphError::</span>QueryTooShort)<span class="op">?;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">if</span> query_words<span class="op">.</span>next()<span class="op">.</span>is_some() <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">return</span> <span class="cn">Err</span>(<span class="pp">GraphError::</span>QueryTooLong)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="kw">let</span> src    <span class="op">=</span> label_map<span class="op">.</span>get_index(w1)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    <span class="op">.</span>ok_or_else(<span class="op">||</span> <span class="pp">GraphError::</span>UnknownLabel(w1<span class="op">.</span>to_owned()))<span class="op">?;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="kw">let</span> dst    <span class="op">=</span> label_map<span class="op">.</span>get_index(w2)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="op">.</span>ok_or_else(<span class="op">||</span> <span class="pp">GraphError::</span>UnknownLabel(w2<span class="op">.</span>to_owned()))<span class="op">?;</span></span></code></pre></div>
<p>(We use <code>Option::ok_or</code> and <code>Option::ok_or_else</code> to replace <code>None</code>s with <code>Err</code>s. The former is suitable when the value to put in the <code>Err</code> is free to construct, whereas the latter takes a closure to construct the error value, so that we can avoid doing so unless we actually need it.)</p>
<p>What about passing on errors that aren’t ours, though—in this case, is there a way to call an operation that might produce an <code>io::Error</code> and then gracefully convert the <code>io::Error</code> into a <code>GraphError</code>? Well, doing the mapping manually isn’t totally awful:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">while</span> line_result <span class="op">=</span> buf_read<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">let</span> line <span class="op">=</span> line_result<span class="op">.</span>map_err(<span class="pp">GraphError::</span>IoError)<span class="op">?;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    …</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>But actually, <code>?</code> will do the conversion for us if we tell it how:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">impl</span> <span class="bu">From</span><span class="op">&lt;</span><span class="pp">std::io::</span>IoError<span class="op">&gt;</span> <span class="kw">for</span> GraphError <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">fn</span> from(err<span class="op">:</span> <span class="pp">std::io::</span><span class="bu">Error</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>        <span class="pp">GraphError::</span>IoError(err)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="op">}</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>And here’s how we use it now:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">while</span> line_result <span class="op">=</span> buf_read<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="kw">let</span> line <span class="op">=</span> line_result<span class="op">?;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    …</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p><a href="index.html">Contents</a></p>
</body>
</html>
